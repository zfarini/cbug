declared struct Token
declared struct Node
declared struct FILE
declared struct Type
declared struct Scope
declared struct Var
declared struct Func
declared struct Enum
declared struct Token_Name
parse function binary
parse function parse_type
parse function parse
parse function function
parse function decl
parse function statement
parse function expr
parse function assign
parse function conditional
parse function logical_or
parse function logical_and
parse function equality
parse function relational
parse function add
parse function mul
parse function cast
parse function unary
parse function postfix
parse function primary
parse function error
parse function error_token
parse function read_entire_file
parse function out
parse function malloc
parse function assert
parse function calloc
parse function isspace
parse function isdigit
parse function isalpha
parse function isalnum
parse function memcpy
parse function strcmp
parse function strdup
parse function strlen
parse function strncmp
parse function strchr
parse function printf
parse function fprintf
parse function fopen
parse function new_node
parse function type_match
parse function dbg
parse function fopen
parse function fseek
parse function ftell
parse function fclose
parse function fread
parse function exit
char*
int
char*
char*
int
char*
parse function token_type_name
int
int
int
parse function new_temp_token
parse function get_backspace_char
char*
int
parse function add_multi_char_token
char*
int
parse function add_keyword
int
char*
int
int
int
long
long
long
int
long
long
int
char*
int
char*
char*
int
int
char*
char*
char*
char*
int
int
char*
int
int
int
int
int
char*
int
int
parse function tokenize
parse function align
parse function find
parse function new_scope
struct Scope*
parse function enter_scope
struct Scope*
parse function leave_scope
int
int
int
int
int
int
int
int
int
parse function new_type
int
int
int
int
struct Type*
struct Type*
struct Type*
struct Type*
parse function types_are_equal
char*
struct Type*
parse function add_func
char*
parse function find_func
int
struct Var*[]
char*
struct Var*[]
struct Scope*
struct Type*
char*
struct Token*
parse function find_var
int
struct Var*[]
char*
char*
struct Token*
struct Type*
int
struct Var*[]
int
int
int
int
struct Type*
int
int
int
int
int
int
struct Type*
int
int
int
parse function new_var
int
parse function skip
int
int
int
int
int
int
int
int
int
char*
char*
parse function is_typename
struct Type*
struct Type*
parse function find_binary_op_type
parse function strjoin
int
char*
int
struct Type*
int
struct Type*
int
int
int
int
int
int
parse function get_type_str
parse function add_type
struct Type*
struct Node*
struct Type*
parse function implicit_cast
struct Type*
struct Type*
int
int
int
int
int
int
int
parse function find_common_type
struct Type*
struct Type*
int
struct Token*
struct Token*
long
long
int
struct Node*
int
struct Token*
struct Token*
int
int
struct Node*
int
struct Token*
struct Token*
int
struct Token*
int
struct Node*
int
struct Type*
int
struct Var*
struct Type*
int
struct Func*
struct Type*
int
struct Type*
struct Node*
struct Type*
int
struct Token*
int
struct Node*
struct Type*
struct Token*
struct Type*
int
struct Token*
struct Type*
int
struct Node*
int
struct Token*
int
struct Type*
struct Node*
int
struct Token*
int
struct Node*
struct Node*
struct Node*
struct Type*
struct Node*
struct Type*
int
int
struct Type*
struct Type*
struct Type*
struct Type*
struct Type*
struct Type*
struct Type*
struct Token*
struct Type*
struct Type*
struct Type*
struct Type*
struct Node*
struct Type*
struct Node*
struct Type*
struct Node*
struct Node*
struct Token*
int
struct Node*
struct Type*
int
struct Node*
struct Node*
struct Node*
int
struct Node*
struct Node*
struct Node*
struct Node*
struct Type*
struct Node*
struct Type*
struct Node*
struct Node*
struct Type*
struct Node*
parse function add_type
struct Scope*
int
int
int
int
char*
char*
int
int
long
int
int
int
int
char*
char*
int
int
struct Node*
char*[]
struct Var*
char*
struct Type*[]
struct Var*
struct Type*
struct Var*
struct Type*
int
int[]
struct Var*
struct Type*
int
struct Var*
struct Type*
int
struct Var*
struct Type*
int
struct Var*
struct Type*
struct Var*
struct Type*
int
int
struct Var*
struct Type*
int
struct Node*
int
int
int
struct Type*[]
struct Type*
struct Type*
struct Type*
struct Token*
char*
char*
int
struct Type*
struct Type*
char*
int
struct Node*
struct Node*
struct Node*
struct Node*
int
struct Type*[]
struct Type*[]
struct Type*
struct Type*
int
struct Type*[]
struct Type*
struct Token*
char*
int
int
struct Type*[]
char*[]
parse function parse
char*
parse function find_type
int
char*
int
int
int
int
int
int
int
struct Token*
int
parse function parse_base_type
int
int
struct Type*
parse function parse_type
int
int
struct Node*[]
struct Node*[]
struct Var*
char*
int
int
int
struct Func*
struct Token*
char*
int
int
struct Node*
struct Token*
char*
parse function function
parse function statement_or_decl
struct Type*
struct Node*
int
struct Type*
struct Type*
int
int
struct Type*
int
int
struct Type*
int
struct Type*
int
int
long
char*
char*
struct Type*
char*
char*
char*
struct Type*
char*
struct Node*
struct Node*
struct Scope*
int
struct Node*
struct Var*
int
int
int
struct Token*
int
int
int
int
int
struct Token*
struct Token*
long
struct Token*
struct Node*
struct Node*
struct Var*
struct Node*
struct Node*
struct Token*
struct Node*
struct Token*
long
struct Token*
struct Node*
struct Token*
struct Node*
struct Node*
struct Node*
struct Node*
int
int
struct Node*
struct Node*
struct Node*
struct Node*
struct Node*
struct Node*
int
struct Node*
parse function decl
int
int
struct Node*
struct Node*
int
int
int
struct Node*
struct Node*
int
struct Node*
int
struct Node*
struct Node*
int
int
struct Node*
struct Node*
int
struct Node*
int
struct Node*
struct Node*
int
int
int
struct Node*
struct Node*
struct Node*
struct Node*
struct Node*
struct Node*
int
parse function statement
int
struct Node*
struct Node*
parse function expr
int
int
int
int
struct Type*
struct Type*
int
int
struct Node*
struct Node*
struct Token*
int
struct Token*
struct Token*
char*
struct Node*
struct Node*
struct Node*
struct Node*
parse function assign
int
struct Node*
struct Node*
struct Node*
parse function conditional
parse function logical_or
parse function logical_and
parse function equality
parse function relational
parse function add
parse function mul
int
struct Type*
struct Node*
parse function cast
int
int
struct Node*
int
struct Node*
int
struct Node*
int
struct Node*
int
struct Token*
int
int
struct Token*
long
int
int
struct Token*
long
int
int
int
struct Token*
int
int
struct Node*
struct Node*
struct Node*
struct Token*
struct Node*
struct Token*
long
struct Token*
struct Node*
struct Node*
struct Node*
parse function unary
int
struct Token*
struct Node*
struct Node*
struct Token*
struct Node*
int
int
struct Node*
int
int
struct Node*
struct Type*
int
int
int
int
struct Type*
int
int
char*[]
char*
int
struct Type*
int
struct Node*
struct Token*
struct Node*
struct Node*
struct Node*
struct Token*
struct Node*
struct Token*
long
int[]
struct Type*[]
int
struct Type*[]
struct Type*
struct Type*[]
struct Node*
struct Node*
parse function postfix
int
int
int
int
int
struct Func*
char*
struct Func*
struct Token*
char*
int
struct Token*
char*
int
struct Node*[]
struct Node*[]
int
int
int
int
char*
char*
char*
struct Token*
struct Token*
long
int
char*
struct Var*
parse function primary
parse function get_inst_suffix
parse function get_size_name
parse function log2_int
parse function get_register_by_size
parse function add_string_lit
parse function push
parse function pop
int
int
struct Node*
struct Node*
int
struct Node*
struct Token*
char*
struct Func*
struct Type*
struct Token*
char*
int
struct Node*[]
struct Var*
struct Type*
struct Node*[]
struct Var*
char*
int
struct Token*
char*
int
int
int
struct Node*[]
struct Var*
struct Type*
int
struct Type*
int
int
char*
int
struct Node*[]
struct Var*
int
int
struct Node*[]
struct Var*
struct Type*
int
struct Node*[]
struct Var*
struct Type*
int
struct Node*[]
struct Var*
int
struct Node*[]
struct Var*
char*
struct Node*
int
int
int
struct Node*
struct Token*
int
struct Node*
int
struct Node*
int
struct Node*
struct Var*
int
struct Var*
int
struct Node*
struct Node*
struct Node*
int
struct Node*
int
struct Node*
struct Node*
struct Node*
struct Node*
int
struct Node*
struct Node*
int
struct Node*
struct Node*
struct Node*
struct Node*
struct Node*
int
struct Type*
int
struct Token*
long
struct Token*
long
int
struct Token*
char*
int
struct Type*
struct Type*
int
int
struct Var*
int
struct Var*
char*
struct Var*
char*
struct Var*
int
struct Type*
int
struct Token*
char*
struct Var*
int
struct Type*
int
struct Type*
int
struct Type*
int
struct Var*
char*
struct Var*
char*
struct Type*
int
struct Var*
char*
struct Type*
int
struct Var*
char*
struct Type*
int
struct Type*
int
struct Var*
char*
struct Var*
char*
struct Type*
int
struct Type*
int
struct Type*
int
struct Var*
int
struct Var*
char*
struct Type*
int
struct Var*
int
struct Type*
int
struct Var*
char*
struct Type*
int
struct Type*
int
struct Var*
int
struct Var*
char*
struct Var*
int
struct Var*
char*
int
struct Token*
char*
struct Token*
char*
struct Token*
char*
struct Token*
char*
struct Node*[]
struct Node*[]
struct Token*
int
struct Token*
int
struct Token*
int
struct Token*
char*
int
struct Node*[]
int
int
int
int
int
struct Node*[]
struct Token*
char*
int
int
int
struct Node*
int
struct Node*
struct Node*
struct Node*
struct Node*
int
struct Node*
struct Node*
struct Node*
int
struct Node*
struct Var*
int
struct Node*
struct Var*
char*
struct Node*
struct Var*
char*
struct Node*
struct Var*
int
struct Node*
int
struct Node*
struct Node*
struct Node*
int
struct Node*
struct Node*
struct Type*
struct Type*
struct Token*
struct Type*
int
struct Type*
int
struct Type*
int
int
struct Node*
struct Node*
struct Type*
struct Type*
struct Token*
int
struct Type*
struct Node*
struct Node*
struct Type*
struct Type*
struct Type*
int
struct Type*
struct Type*
struct Type*
int
int
int
int
int
int
int
int
int
int
int
int
int
int
int
int
int
struct Node*
struct Token*
int
struct Token*
int
struct Node*
struct Node*
struct Token*
struct Token*
int
int
struct Node*
struct Type*
struct Node*
struct Type*
struct Type*
struct Type*
struct Node*
struct Type*
struct Type*
int
struct Node*
struct Type*
struct Node*
struct Type*
struct Token*
struct Type*
struct Type*
int
struct Node*
struct Type*
struct Type*
int
struct Token*
int
struct Token*
int
struct Token*
int
struct Token*
struct Token*
int
int
struct Type*
int
struct Token*
int
struct Token*
int
struct Token*
int
struct Token*
int
struct Token*
int
struct Token*
int
struct Token*
int
struct Token*
int
struct Node*
struct Type*
struct Node*
struct Type*
struct Token*
struct Type*
struct Type*
int
struct Node*
struct Type*
struct Type*
int
int
struct Node*
int
struct Node*
struct Node*
struct Node*
struct Node*
int
struct Node*
struct Type*
int
struct Node*
struct Type*
int
struct Node*
struct Node*
struct Node*
struct Node*
struct Type*
struct Type*
struct Token*
struct Type*
int
struct Type*
int
struct Node*
int
struct Node*
struct Node*
struct Type*
struct Node*
struct Var*
struct Type*
struct Type*
int
struct Token*
struct Node*
struct Var*
int
struct Type*
int
struct Type*
int
struct Type*
int
struct Node*
struct Var*
char*
struct Type*
int
struct Node*
struct Var*
int
struct Node*
struct Var*
struct Type*
int
struct Type*
int
struct Type*
int
struct Node*
struct Var*
int
struct Node*
struct Var*
char*
int
struct Token*
int
struct Token*
int
struct Node*
struct Token*
int
struct Token*
struct Token*
int
int
struct Token*
struct Token*
long
struct Token*
int
struct Token*
struct Node*
struct Node*
struct Node*
struct Node*
struct Token*
struct Node*
struct Node*
struct Node*
struct Node*
struct Node*
int
struct Node*
struct Node*
struct Node*
struct Node*
struct Node*
parse function gen
int
int
struct Node*
struct Node*
int
struct Token*
char*
int
struct Node*[]
struct Var*
struct Type*
struct Node*[]
struct Var*
char*
int
struct Func*
struct Type*
struct Token*
int
struct Node*
int
struct Node*
struct Node*
int
struct Node*
struct Type*
struct Var*
struct Type*
struct Type*
struct Type*
struct Node*
struct Var*
char*
struct Node*
struct Node*
struct Var*
int
struct Node*
int
struct Node*
struct Node*
int
int
struct Token*
int
struct Node*
struct Node*
int
struct Node*
struct Node*
int
struct Node*
struct Node*
int
struct Node*
int
struct Node*
int
struct Node*
struct Node*
struct Node*
int
struct Node*
struct Node*
struct Node*
int
struct Node*
int
struct Node*
struct Token*
int
struct Token*
char*
int
struct Token*
long
int
struct Var*
char*
int
struct Token*
char*
int
struct Token*
char*
int
struct Node*[]
int
int
int
int
struct Token*
int
struct Node*
int
struct Type*
struct Node*
int
struct Node*
struct Token*
int
struct Node*
int
struct Node*
struct Token*
int
struct Node*
int
int
int
struct Token*
int
struct Node*
struct Node*
int
struct Node*
struct Node*
struct Node*
struct Node*
struct Node*
parse function print
parse function read_entire_file
int
struct Var*[]
struct Node*
struct Node*
struct Node*
struct Node*
int
struct Var*
char*
struct Node*
struct Token*
int
struct Node*
struct Token*
struct Var*
struct Type*
int
struct Var*
char*
struct Var*
struct Type*
struct Var*
struct Type*
int
int
struct Var*
char*
struct Var*
struct Type*
int
struct Var*[]
char*
struct Var*[]
struct Type*
int
struct Node*
struct Node*
struct Token*
struct Node*
long
parse function main
declared struct 'Token': (size=40)
	int type
	long int_val
	char* name
	int line
	int col
	char* str
declared struct 'Node': (size=1784)
	int type
	struct Var* var
	struct Token* tok
	struct Node* left
	struct Node* right
	struct Node* next_stmt
	struct Node* body
	struct Node* condition
	struct Node* init
	struct Node* inc
	struct Node* next_in_block
	struct Node* next_in_decl
	struct Node* first_stmt
	struct Node* next_in_comma
	struct Type* cast_type
	struct Type* decl_type
	struct Type* ret_type
	struct Node* else_
	struct Type* t
	struct Func* func
	int member_idx
	struct Node*[] args
	struct Node*[] params
	int arg_count
	int param_count
	int stack_size
declared struct 'FILE': (size=8)
	int x
	int y
declared struct 'Type': (size=2056)
	int t
	struct Type* ptr_to
	struct Token* tok
	int array_size
	int size
	int is_unsigned
	char* name
	struct Type*[] field_type
	char*[] field_name
	int[] field_offset
	int field_count
declared struct 'Scope': (size=840)
	struct Scope* parent
	struct Scope* prev
	struct Scope* child
	struct Scope* next
	struct Var*[] vars
	int var_count
declared struct 'Var': (size=48)
	struct Type* type
	char* name
	int offset
	struct Token* token
	int global
	struct Node* decl
declared struct 'Func': (size=16)
	struct Type* ret_type
	char* name
declared struct 'Enum': (size=16)
	char* name
	int value
declared struct 'Token_Name': (size=16)
	char* name
	int type

function binary() -> struct Node*  (185)


function parse_type() -> struct Type*  (186)


function parse() -> struct Node*  (187)


function function() -> struct Node*  (188)


function decl() -> struct Node*  (189)


function statement() -> struct Node*  (190)


function expr() -> struct Node*  (191)


function assign() -> struct Node*  (192)


function conditional() -> struct Node*  (193)


function logical_or() -> struct Node*  (194)


function logical_and() -> struct Node*  (195)


function equality() -> struct Node*  (196)


function relational() -> struct Node*  (197)


function add() -> struct Node*  (198)


function mul() -> struct Node*  (199)


function cast() -> struct Node*  (200)


function unary() -> struct Node*  (201)


function postfix() -> struct Node*  (202)


function primary() -> struct Node*  (203)


function error() -> void  (204)


function error_token() -> void  (205)


function read_entire_file() -> char*  (206)


function out() -> void  (207)


function malloc() -> void*  (209)


function assert() -> int  (210)


function calloc() -> void*  (211)


function isspace() -> int  (212)


function isdigit() -> int  (213)


function isalpha() -> int  (214)


function isalnum() -> int  (215)


function memcpy() -> void  (216)


function strcmp() -> int  (217)


function strdup() -> char*  (218)


function strlen() -> int  (219)


function strncmp() -> int  (220)


function strchr() -> int  (221)


function printf() -> int  (222)


function fprintf() -> int  (223)


function fopen() -> struct FILE*  (224)


function new_node() -> struct Node*  (225)


function type_match() -> int  (227)


function dbg() -> void  (228)


function fopen() -> struct FILE*  (229)


function fseek() -> int  (230)


function ftell() -> long  (231)


function fclose() -> int  (232)


function fread() -> long  (233)


function exit() -> void  (234)

char *filename;
char *program_str;
struct FILE *f;
struct Type *types;
int type_count;
struct Type **types_declared;
int types_declared_count;
char **strings_literal;
int strings_literal_count;
struct Type *type_long;
struct Type *type_int;
struct Type *type_short;
struct Type *type_char;
struct Type *type_void;
struct Func *funcs;
int func_count;
struct Scope *scopes;
int scope_count = 0;
struct Scope *curr_scope;
struct Token *tokens;
int ct;
struct Node *_nodes;
int _curr_node;
struct Var *vars;
int var_count = 0;
struct Enum *enums;
int enum_count;
struct Node *curr_func;
struct Token_Name *multi_char_tokens_type;
struct Token_Name *keywords;
char **token_type_name_c;

function token_type_name(int type) -> char*  (283)
{
    if (type == 256)
        return "int";
    else if (type == 257)
        return "identifier";
    else if (type == 274)
        return "string";
    else if (type < 255)
    {
        if (!(*(token_type_name_c + type)))
        {
            *(token_type_name_c + type) = ((char*)malloc(2))
            *(*(token_type_name_c + type) + 0) = ((char)type)
            *(*(token_type_name_c + type) + 1) = ((char)0)
        }

        return *(token_type_name_c + type);
    }
    else 
    {
        for (int i = 0; *(multi_char_tokens_type + i).name ;i++)
        {
            if (*(multi_char_tokens_type + i).type == type)
                return *(multi_char_tokens_type + i).name;

        }

        for (int i = 0; *(keywords + i).name ;i++)
        {
            if (*(keywords + i).type == type)
                return *(keywords + i).name;

        }

    }

    (NULL)
}


function new_temp_token(int type) -> struct Token*  (317)
{
    struct Token *t = ((struct Token*)calloc(40, 1));
    t->type = type
    t->line = -(1)
    t->col = -(1)
    return t;
}


function get_backspace_char(char c) -> char  (326)
{
    if (((int)c) == 110)
        return 10;

    if (((int)c) == 116)
        return 9;

    if (((int)c) == 114)
        return 13;

    if (((int)c) == 118)
        return 11;

    if (((int)c) == 102)
        return 12;

    if (((int)c) == 97)
        return 7;

    if (((int)c) == 98)
        return 8;

    return c;
}

int multi_char_token_count = 0;
int keyword_count = 0;

function add_multi_char_token(char* name, int type) -> void  (341)
{
    *(multi_char_tokens_type + multi_char_token_count).name = name
    *(multi_char_tokens_type + multi_char_token_count).type = type
    multi_char_token_count++
}


function add_keyword(char* name, int type) -> void  (348)
{
    *(keywords + keyword_count).name = name
    *(keywords + keyword_count).type = type
    keyword_count++
}


function tokenize(char* s) -> struct Token*  (355)
{
    add_multi_char_token("==", 260)
    add_multi_char_token("!=", 261)
    add_multi_char_token("<=", 262)
    add_multi_char_token(">=", 263)
    add_multi_char_token("&&", 258)
    add_multi_char_token("||", 259)
    add_multi_char_token("++", 275)
    add_multi_char_token("--", 276)
    add_multi_char_token("+=", 282)
    add_multi_char_token("-=", 283)
    add_multi_char_token("*=", 284)
    add_multi_char_token("/=", 285)
    add_multi_char_token("->", 288)
    add_multi_char_token(0, 0)
    add_keyword("return", 264)
    add_keyword("for", 268)
    add_keyword("while", 267)
    add_keyword("if", 265)
    add_keyword("else", 266)
    add_keyword("int", 269)
    add_keyword("void", 270)
    add_keyword("char", 271)
    add_keyword("short", 272)
    add_keyword("long", 273)
    add_keyword("unsigned", 279)
    add_keyword("signed", 280)
    add_keyword("break", 277)
    add_keyword("continue", 278)
    add_keyword("sizeof", 281)
    add_keyword("long", 273)
    add_keyword("struct", 286)
    add_keyword("union", 287)
    add_keyword("enum", 289)
    int i = 0, j = 0;
    int line = 1;
    int col = 1;
    (NULL)
    while (*(s + i))
    {
        struct Token *token = &(*(tokens + j));
        token->type = 0
        while (isspace(*(s + i)))
        {
            if (((int)*(s + i)) == 10)
            {
                line++
                col = 1
            }
            else 
                col++
            i++
        }

        if (!(*(s + i)))
            break ;

        if (((int)*(s + i)) == 35)
        {
            while (((int)*(s + i)) != 10)
                i++

            continue ;
        }
        else if (((int)*(s + i)) == 47 && ((int)*(s + i + 1)) == 47)
        {
            while (((int)*(s + i)) && ((int)*(s + i)) != 10)
                i++

            continue ;
        }

        if (((int)*(s + i)) == 47 && ((int)*(s + i + 1)) == 42)
        {
            i += i + 2
            while (((int)*(s + i)) && ((int)*(s + i)) != 42 || ((int)*(s + i + 1)) != 47)
                i++

            if (*(s + i))
                i += i + 2
            else 
                error("unclosed comment")
            continue ;
        }

        token->str = s + i
        token->line = line
        token->col = col
        int last = i;
        if (isdigit(*(s + i)))
        {
            token->type = 256
            token->int_val = ((long)0)
            while (isdigit(*(s + i)))
            {
                token->int_val = token->int_val * ((long)10) + ((long)((int)*(s + i)) - 48)
                i++
            }

        }
        else if (((int)*(s + i)) == 39)
        {
            i++
            token->type = 256
            if (((int)*(s + i)) == 92)
            {
                i++
                token->int_val = ((long)get_backspace_char(*(s + i)))
            }
            else 
                token->int_val = ((long)*(s + i))
            i++
            if (((int)*(s + i)) != 39)
                error_token(token, "missing terminating ' character")

            i++
        }
        else if (((int)*(s + i)) == 34)
        {
            i++
            token->type = 274
            int k = i;
            while (((int)*(s + i)) && ((int)*(s + i)) != 34 || ((int)*(s + i - 1)) == 92)
                i++

            if (((int)*(s + i)) != 34)
                error_token(token, "missing terminating \" character")

            char *name = ((char*)malloc(i - k + 1));
            memcpy(name, s + k, i - k)
            *(name + i - k) = ((char)0)
            token->name = name
            i++
        }
        else if (isalpha(*(s + i)) || ((int)*(s + i)) == 95)
        {
            int k = i;
            while (isalnum(*(s + i)) || ((int)*(s + i)) == 95)
                i++

            char *name = ((char*)malloc(i - k + 1));
            memcpy(name, s + k, i - k)
            *(name + i - k) = ((char)0)
            token->type = 257
            for (int l = 0; *(keywords + l).name ;l++)
            {
                if (!(strcmp(name, *(keywords + l).name)))
                {
                    token->type = *(keywords + l).type
                    break ;
                }

            }

            token->name = name
        }
        else 
        {
            for (int k = 0; *(multi_char_tokens_type + k).name ;k++)
            {
                if (!(strncmp(s + i, *(multi_char_tokens_type + k).name, strlen(*(multi_char_tokens_type + k).name))))
                {
                    token->type = *(multi_char_tokens_type + k).type
                    i += i + strlen(*(multi_char_tokens_type + k).name)
                    break ;
                }

            }

            if (!(token->type))
            {
                if (strchr("+-*/%()=;,<>{}&[]?:.!", *(s + i)))
                {
                    token->type = ((int)*(s + i))
                    i++
                }
                else 
                {
                    error_token(token, "unknown token `%c`", *(s + i))
                }

            }

        }

        col += col + i - last
        j++
    }

    *(tokens + j).type = 0
    *(tokens + j).line = line, *(tokens + j).col = col
    *(tokens + j).str = s + i
    if (((int)*(s + i - 1)) == 10)
        *(tokens + j).line++, *(tokens + j).col = 1

    return tokens;
}


function align(int n, int a) -> int  (540)
{
    return n + a - 1 / a * a;
}


function find(char* s, char c) -> char*  (545)
{
    int i;
    i = 0
    while (*(s + i))
    {
        if (((int)*(s + i)) == ((int)c))
            return s + i;

        i++
    }

    return 0;
}


function new_scope() -> struct Scope*  (561)
{
    struct Scope *scope = &(*(scopes + scope_count++));
    return scope;
}


function enter_scope() -> void  (567)
{
    struct Scope *scope = new_scope();
    scope->parent = curr_scope
    curr_scope = scope
}


function leave_scope() -> void  (574)
{
    curr_scope = curr_scope->parent
}


function new_type(int t) -> struct Type*  (579)
{
    struct Type *type = &(*(types + type_count++));
    type->t = t
    if (t == 1 || t == 3 || t == 8)
        type->is_unsigned = 1

    if (t == 1 || t == 3 || t == 6 || t == 8)
        type->size = 8
    else if (type->t == 0)
        type->size = 4
    else if (type->t == 4)
        type->size = 2
    else if (type->t == 5)
        type->size = 1

    return type;
}


function types_are_equal(struct Type* t1, struct Type* t2) -> int  (596)
{
    if (!(t1) || !(t2))
        return 0;

    if (t1 == t2)
        return 1;

    if (t1->is_unsigned != t2->is_unsigned)
        return 0;

    if (t1->t != t2->t)
        return 0;

    if (!(t1->ptr_to))
        return t2->ptr_to == 0;

    return types_are_equal(t1->ptr_to, t2->ptr_to);
}


function add_func(char* name, struct Type* ret_type) -> struct Func*  (611)
{
    struct Func *fn = &(*(funcs + func_count++));
    fn->name = name
    fn->ret_type = ret_type
    return fn;
}


function find_func(char* name) -> struct Func*  (619)
{
    for (int i = 0; i < func_count ;i++)
    {
        if (!(strcmp(name, *(funcs + i).name)))
            return &(*(funcs + i));

    }

    return 0;
}


function find_var(char* name) -> struct Var*  (629)
{
    struct Scope *scope = curr_scope;
    while (scope)
    {
        for (int i = 0; i < scope->var_count ;i++)
        {
            if (!(strcmp(*(scope->vars + i)->name, name)))
                return *(scope->vars + i);

        }

        scope = scope->parent
    }

    struct Func *func = find_func(name);
    if (!(func))
        return 0;

    struct Type *type = new_type(8);
    struct Var *v = &(*(vars + var_count++));
    v->type = type
    v->name = name
    v->token = &(*(tokens + ct))
    return v;
}


function new_var(struct Type* type, char* name) -> struct Var*  (653)
{
    for (int i = 0; i < curr_scope->var_count ;i++)
    {
        if (!(strcmp(*(curr_scope->vars + i)->name, name)))
            error_token(&(*(tokens + ct)), "redeclaration of variable \"%s\"\n", name)

    }

    struct Var *v = &(*(vars + var_count++));
    v->name = name
    v->token = &(*(tokens + ct))
    (NULL)
    v->type = type
    *(curr_scope->vars + curr_scope->var_count++) = v
    if (!(type->size))
        error_token(&(*(tokens + ct)), "type with size 0?")

    if (curr_func && type->size)
    {
        if (type->t == 3)
        {
            curr_func->stack_size += curr_func->stack_size + type->ptr_to->size * type->array_size
        }
        else 
            curr_func->stack_size += curr_func->stack_size + type->size
        curr_func->stack_size = align(curr_func->stack_size, v->type->size)
        v->offset = curr_func->stack_size
        (NULL)
    }

    return v;
}


function skip(int type) -> void  (684)
{
    if (*(tokens + ct).type != type)
        error_token(&(*(tokens + ct)), "expected `%s`", token_type_name(type))

    ct++
}


function is_typename(struct Token* tok) -> int  (691)
{
    if (tok->type == 269 || tok->type == 270 || tok->type == 271 || tok->type == 272 || tok->type == 273 || tok->type == 280 || tok->type == 279 || tok->type == 270)
        return 1;

    if (tok->type == 257)
    {
        for (int i = 0; i < types_declared_count ;i++)
        {
            if (!(strcmp(*(types_declared + i)->name, tok->name)))
                return 1;

        }

    }

    return 0;
}


function find_binary_op_type(struct Type* t1, struct Type* t2) -> struct Type*  (715)
{
    if (types_are_equal(t1, t2))
        return t1;

    if (t1->ptr_to && !(t2->ptr_to))
        (NULL)

    return 0;
}


function strjoin(char* s1, char* s2) -> char*  (725)
{
    int l1 = strlen(s1);
    int l2 = strlen(s2);
    char *s = ((char*)malloc(l1 + l2 + 1));
    memcpy(s, s1, l1)
    memcpy(s + l1, s2, l2)
    *(s + l1 + l2) = ((char)0)
    return s;
}


function get_type_str(struct Type* type) -> char*  (736)
{
    if (type->t == 7)
    {
        return strjoin("struct ", type->name);
    }

    if (type->t == 1)
    {
        return strjoin(get_type_str(type->ptr_to), "*");
    }
    else if (type->t == 3)
    {
        return strjoin(get_type_str(type->ptr_to), "[]");
    }

    if (type->t == 2)
        return "void";

    if (type->t == 5)
        return "char";

    if (type->t == 0)
        return "int";

    if (type->t == 4)
        return "short";

    if (type->t == 6)
        return "long";

    if (type->t == 9)
        return "unknown";

    (NULL)
}


function add_type(struct Node* node) -> struct Type*  (759)


function implicit_cast(struct Node** node, struct Type* type) -> void  (761)
{
    add_type(*(node))
    if (types_are_equal(type, *(node)->t))
        return (NULL);

    struct Node *cast = new_node(22);
    cast->left = *(node)
    cast->t = type
    *(node) = cast
}


function find_common_type(struct Type* t1, struct Type* t2) -> struct Type*  (772)
{
    if (t1->ptr_to)
        return t1;

    if (t2->ptr_to)
        return t2;

    if (t1->size < 4)
        t1 = type_int

    if (t2->size < 4)
        t2 = type_int

    if (t1->size != t2->size)
        return ((t1->size < t2->size) ? (t2) : (t1);

    return ((t2->is_unsigned) ? (t2) : (t1);
}


function add_type(struct Node* node) -> struct Type*  (787)
{
    struct Type *t = type_void;
    if (!(node))
        return t;

    if (node->t)
        t = node->t
    else if (node->type == 4)
    {
        if (node->tok->int_val > ((long)2147483647) || node->tok->int_val < -(2147483648))
            t = type_long
        else 
            t = type_int
    }
    else if (node->type == 24)
    {
        t = add_type(node->left)
        printf("%s\n", get_type_str(t))
    }
    else if (node->type == 14)
    {
        if (node->tok->type == 275 || node->tok->type == 276)
        {
            t = add_type(node->left)
            if (t->t == 2)
                error_token(node->tok, "invalid operand for '%s' operator", token_type_name(node->tok->type))

        }
        else if (node->tok->type == 33)
        {
            add_type(node->left)
            t = type_int
        }
        else 
            (NULL)
    }
    else if (node->type == 19)
    {
        t = new_type(1)
        t->ptr_to = type_char
    }
    else if (node->type == 2)
        t = node->var->type
    else if (node->type == 13)
        t = node->func->ret_type
    else if (node->type == 17)
    {
        t = new_type(1)
        t->ptr_to = add_type(node->left)
        if (t->ptr_to->t == 2)
            error_token(node->tok, "invalid operand for '&'")

    }
    else if (node->type == 16)
    {
        struct Type *tt = add_type(node->left);
        if (!(tt->ptr_to))
            error_token(node->tok, "derefrencing a non-pointer")

        if (tt->ptr_to->t == 2)
            error_token(node->tok, "derefrencing a void pointer")

        t = tt->ptr_to
    }
    else if (node->type == 7)
    {
        t = add_type(node->left)
        if (t->t == 2)
            error_token(node->tok, "invalid operand for '-'")

    }
    else if (node->type == 22)
    {
        t = node->cast_type
        add_type(node->left)
    }
    else if (node->type == 5)
    {
        int tok = node->tok->type;
        add_type(node->left)
        add_type(node->right)
        struct Type *t1 = node->left->t;
        struct Type *t2 = node->right->t;
        if (t1->t == 2 || t2->t == 2)
            (NULL)

        if (t1->ptr_to || t2->ptr_to)
        {
            if (type_match(tok, 42, 47, 37, -(1)) || !(t1->ptr_to) && tok == 45 || t1->ptr_to && t2->ptr_to && tok == 43 || t1->ptr_to && t2->ptr_to && tok == 45 && !(types_are_equal(t1, t2)))
                error_token(node->tok, "invalid operands to binary expression ('%s' and '%s')", get_type_str(t1), get_type_str(t2))

            if (t1->ptr_to && !(t2->ptr_to) && tok == 43 || tok == 45)
                t = t1
            else if (t2->ptr_to && !(t1->ptr_to) && tok == 43)
                t = t2
            else 
                t = type_int
        }
        else 
        {
            struct Type *tt = find_common_type(node->left->t, node->right->t);
            implicit_cast(&(node->left), tt)
            implicit_cast(&(node->right), tt)
            if (type_match(node->tok->type, 43, 45, 42, 47, 37, -(1)))
                t = node->left->t
            else 
                t = type_int
        }

    }
    else if (node->type == 6)
    {
        t = add_type(node->left)
        (NULL)
        add_type(node->right)
        implicit_cast(&(node->right), t)
    }
    else if (node->type == 23)
    {
        add_type(node->condition)
        add_type(node->left)
        add_type(node->right)
        struct Type *tt = find_common_type(node->left->t, node->right->t);
        implicit_cast(&(node->left), tt)
        implicit_cast(&(node->right), tt)
        t = tt
    }
    else 
        (NULL)
    node->t = t
    add_type(node->next_in_comma)
    return t;
}


function parse(char* s) -> struct Node*  (919)
{
    add_func("ASSERT", type_void)
    tokenize(s)
    ct = 0
    struct Node *prog = new_node(1);
    curr_scope = new_scope()
    curr_scope->parent = ((struct Scope*)0)
    struct Node *curr = prog;
    while (*(tokens + ct).type)
    {
        int save = ct;
        if (*(tokens + ct).type == 289)
        {
            ct++
            if (*(tokens + ct).type == 257)
                ct++

            skip(123)
            int val = 0;
            while (*(tokens + ct).type != 125)
            {
                *(enums + enum_count).name = *(tokens + ct).name
                skip(257)
                if (*(tokens + ct).type == 61)
                {
                    ct++
                    if (*(tokens + ct).type != 256)
                        skip(256)

                    val = ((int)*(tokens + ct).int_val)
                    ct++
                }

                if (*(tokens + ct).type == 44)
                    ct++
                else if (*(tokens + ct).type != 125)
                    skip(125)

                *(enums + enum_count).value = val
                enum_count++
                val++
            }

            skip(125)
            skip(59)
        }
        else if (*(tokens + ct).type == 286)
        {
            struct Token *st_token = &(*(tokens + ct));
            struct Type *type = new_type(7);
            ct++
            type->name = *(tokens + ct).name
            skip(257)
            skip(123)
            int i = 0;
            int size = 0;
            int max = 0;
            while (*(tokens + ct).type && *(tokens + ct).type != 125)
            {
                struct Node *node = decl(1);
                node = node->next_in_decl
                while (node)
                {
                    *(type->field_name + i) = node->var->name
                    *(type->field_type + i) = node->var->type
                    (NULL)
                    size = align(size, node->var->type->size)
                    *(type->field_offset + i) = size
                    if (node->var->type->size > max)
                        max = node->var->type->size

                    if (node->var->type->t == 3)
                        size += size + node->var->type->size * node->var->type->array_size
                    else 
                        size += size + node->var->type->size
                    i++
                    node = node->next_in_decl
                }

                skip(59)
            }

            if (!(size))
                error_token(st_token, "empty structs are not handled yet")

            type->size = align(size, max)
            type->field_count = i
            *(types_declared + types_declared_count++) = type
            for (int j = 0; j < types_declared_count ;j++)
            {
                struct Type *t = *(types_declared + j);
                for (int k = 0; k < t->field_count ;k++)
                {
                    struct Type *cur = *(t->field_type + k);
                    while (cur->ptr_to)
                    {
                        if (cur->ptr_to->t == 9 && !(strcmp(cur->ptr_to->tok->name, type->name)))
                        {
                            cur->ptr_to = type
                            break ;
                        }

                        cur = cur->ptr_to
                    }

                }

            }

            skip(125)
            skip(59)
            printf("declared struct %s\n", type->name)
            continue ;
        }
        else 
        {
            if (!(is_typename(&(*(tokens + ct)))))
                error_token(&(*(tokens + ct)), "expected a function or variable declaration")

            parse_type()
            skip(257)
            int globl = 0;
            if (*(tokens + ct).type != 40)
                globl = 1

            ct = save
            if (globl)
            {
                curr->next_stmt = decl(0)
                skip(59)
            }
            else 
                curr->next_stmt = function()
            if (curr->next_stmt)
                curr = curr->next_stmt

        }

    }

    for (int i = 0; i < types_declared_count ;i++)
    {
        struct Type *t = *(types_declared + i);
        for (int j = 0; j < t->field_count ;j++)
        {
            if (*(t->field_type + j)->ptr_to && *(t->field_type + j)->ptr_to->t == 9)
                error_token(*(t->field_type + j)->ptr_to->tok, "unknown type")

        }

        printf("declared struct '%s': (size=%d)\n", t->name, t->size)
        for (int j = 0; j < t->field_count ;j++)
            printf("\t%s %s\n", get_type_str(*(t->field_type + j)), *(t->field_name + j))
    }

    return prog;
}


function find_type(char* name) -> struct Type*  (1070)
{
    for (int i = 0; i < types_declared_count ;i++)
    {
        if (!(strcmp(*(types_declared + i)->name, name)))
            return *(types_declared + i);

    }

    return 0;
}


function parse_base_type() -> struct Type*  (1080)
{
    int i = 0, s = 0, c = 0, l = 0, v = 0, u = 0, si = 0;
    struct Type *type = ((struct Type*)0);
    struct Token *start = &(*(tokens + ct));
    if (start->type == 257)
    {
        type = find_type(start->name)
        if (type)
        {
            ct++
            return type;
        }

    }

    while (1)
    {
        if (*(tokens + ct).type == 269)
            i++
        else if (*(tokens + ct).type == 270)
            v++
        else if (*(tokens + ct).type == 271)
            c++
        else if (*(tokens + ct).type == 272)
            s++
        else if (*(tokens + ct).type == 273)
            l++
        else if (*(tokens + ct).type == 279)
            u++
        else if (*(tokens + ct).type == 280)
            si++
        else 
            break ;
        ct++
    }

    int err = 0;
    if (i > 1 || v > 1 || c > 1 || s > 1 || u > 1 || si > 1 || l > 2)
        err = 1

    if (si && u)
        err = 1

    if (i + v + c + s > 1)
        err = 1

    if (l && v || c || s)
        err = 1

    if (l)
        type = new_type(6)
    else if (i)
        type = new_type(0)
    else if (v)
        type = new_type(2)
    else if (c)
        type = new_type(5)
    else if (s)
        type = new_type(4)
    else if (si || u)
        type = new_type(0)
    else 
    {
        type = new_type(9)
        type->tok = &(*(tokens + ct))
        ct++
    }

    if (type)
        type->is_unsigned = u

    if (err)
        error_token(start, "invalid type")

    return type;
}


function parse_type() -> struct Type*  (1148)
{
    struct Type *type = parse_base_type();
    while (*(tokens + ct).type == 42)
    {
        struct Type *new = new_type(1);
        new->t = 1
        new->ptr_to = type
        type = new
        ct++
    }

    return type;
}


function function() -> struct Node*  (1162)
{
    enter_scope()
    struct Type *ret_type = parse_type();
    struct Node *node = new_node(15);
    ct++
    curr_func = node
    curr_func->stack_size = 0
    skip(40)
    int count = 0;
    while (*(tokens + ct).type != 41)
    {
        *(node->params + count) = new_node(18)
        struct Type *type = parse_type();
        *(node->params + count)->var = new_var(type, *(tokens + ct).name)
        skip(257)
        count++
        if (*(tokens + ct).type == 44)
            ct++
        else if (*(tokens + ct).type != 41)
            break ;

    }

    skip(41)
    node->param_count = count
    node->func = add_func(node->tok->name, ret_type)
    if (*(tokens + ct).type != 59)
    {
        if (*(tokens + ct).type != 123)
            skip(123)

        node->body = statement()
    }
    else 
        skip(59)
    printf("parse function %s\n", node->tok->name)
    leave_scope()
    curr_func = ((struct Node*)0)
    return node;
}


function statement_or_decl() -> struct Node*  (1205)
{
    if (is_typename(&(*(tokens + ct))))
    {
        struct Node *node = decl(0);
        skip(59)
        return node;
    }

    return statement();
}


function decl(int is_struct) -> struct Node*  (1216)
{
    struct Node *decl = new_node(18);
    struct Type *base = parse_base_type();
    decl->decl_type = base
    struct Node *curr = decl;
    while (1)
    {
        curr->next_in_decl = new_node(18)
        struct Type *type = base;
        while (*(tokens + ct).type == 42)
        {
            struct Type *new = new_type(1);
            new->ptr_to = type
            type = new
            ct++
        }

        if (!(type->ptr_to) && type->t == 9)
            error_token(&(*(tokens + ct)), "unknown type")

        if (type->t == 2 && !(type->ptr_to))
            error_token(&(*(tokens + ct)), "variable type can't be void")

        if (*(tokens + ct).type != 257)
            skip(257)

        struct Var *var;
        if (*(tokens + ct + 1).type == 91)
        {
            struct Type *arr = new_type(3);
            arr->ptr_to = type
            arr->size = arr->ptr_to->size
            arr->array_size = ((int)*(tokens + ct + 2).int_val)
            type = arr
            if (is_struct)
            {
                var = &(*(vars + var_count++))
                var->name = *(tokens + ct).name
                var->type = type
            }
            else 
                var = new_var(type, *(tokens + ct).name)
            ct += ct + 2
            skip(256)
            skip(93)
        }
        else 
        {
            if (is_struct)
            {
                var = &(*(vars + var_count++))
                var->name = *(tokens + ct).name
                var->type = type
            }
            else 
                var = new_var(type, *(tokens + ct).name)
            ct++
        }

        var->decl = curr->next_in_decl
        if (!(curr_scope->parent))
            var->global = 1

        curr->next_in_decl->var = var
        if (*(tokens + ct).type == 61)
        {
            if (*(tokens + ct + 1).type == 123)
            {
                if (type->t != 3)
                    error_token(var->token, "invalid initiliazer")

                ct += ct + 2
                int end = 0;
                struct Node *init = ((struct Node*)0);
                struct Node *c = ((struct Node*)0);
                for (int i = 0;  ;i++)
                {
                    if (*(tokens + ct).type == 125)
                        end = 1

                    if (end && i >= type->array_size)
                        break ;

                    if (i >= type->array_size)
                    {
                        assign()
                        if (*(tokens + ct).type == 44)
                            ct++
                        else if (*(tokens + ct).type != 125)
                            skip(125)

                        continue ;
                    }

                    struct Node *value;
                    if (end)
                    {
                        value = new_node(4)
                        value->tok = new_temp_token(256)
                        value->tok->int_val = ((long)0)
                    }
                    else 
                    {
                        value = assign()
                    }

                    struct Node *add = new_node(5);
                    add->tok = new_temp_token(43)
                    add->left = new_node(2)
                    add->left->var = var
                    add->right = new_node(4)
                    add->right->tok = new_temp_token(269)
                    add->right->tok->int_val = ((long)i)
                    struct Node *deref = new_node(16);
                    deref->tok = new_temp_token(42)
                    deref->left = add
                    struct Node *a = new_node(6);
                    a->tok = new_temp_token(61)
                    a->left = deref
                    a->right = value
                    if (!(c))
                    {
                        c = a
                        init = a
                    }
                    else 
                    {
                        c->next_in_comma = a
                        c = c->next_in_comma
                    }

                    if (*(tokens + ct).type == 44)
                        ct++
                    else if (*(tokens + ct).type != 125)
                        skip(125)

                }

                skip(125)
                curr->next_in_decl->left = init
            }
            else 
            {
                ct++
                curr->next_in_decl->left = assign()
            }

            add_type(curr->next_in_decl->left)
        }

        if (*(tokens + ct).type != 44)
            break ;

        ct++
        curr = curr->next_in_decl
    }

    return decl;
}


function statement() -> struct Node*  (1369)
{
    struct Node *node = ((struct Node*)0);
    if (*(tokens + ct).type == 264)
    {
        node = new_node(8)
        ct++
        if (*(tokens + ct).type != 59)
            node->left = expr()
        else 
            node->left = new_node(0)
        skip(59)
    }
    else if (*(tokens + ct).type == 278)
    {
        node = new_node(20)
        ct++
        skip(59)
    }
    else if (*(tokens + ct).type == 277)
    {
        node = new_node(21)
        ct++
        skip(59)
    }
    else if (*(tokens + ct).type == 265)
    {
        node = new_node(9)
        ct++
        skip(40)
        node->condition = expr()
        skip(41)
        node->body = statement()
        if (*(tokens + ct).type == 266)
        {
            ct++
            node->else_ = statement()
        }

    }
    else if (*(tokens + ct).type == 267)
    {
        node = new_node(10)
        ct++
        skip(40)
        node->condition = expr()
        skip(41)
        node->body = statement()
    }
    else if (*(tokens + ct).type == 268)
    {
        enter_scope()
        node = new_node(11)
        ct++
        skip(40)
        if (*(tokens + ct).type != 59)
        {
            if (is_typename(&(*(tokens + ct))))
                node->init = decl(0)
            else 
                node->init = expr()
        }

        skip(59)
        if (*(tokens + ct).type != 59)
            node->condition = expr()

        skip(59)
        if (*(tokens + ct).type != 41)
            node->inc = expr()

        skip(41)
        node->body = statement()
        leave_scope()
    }
    else if (*(tokens + ct).type == 123)
    {
        node = new_node(12)
        ct++
        struct Node *curr = node;
        enter_scope()
        while (*(tokens + ct).type != 125 && *(tokens + ct).type)
        {
            curr->next_in_block = statement_or_decl()
            (NULL)
            curr = curr->next_in_block
            (NULL)
        }

        node->first_stmt = node->next_in_block
        node->next_in_block = ((struct Node*)0)
        leave_scope()
        curr->next_in_block = ((struct Node*)0)
        skip(125)
    }
    else 
    {
        if (*(tokens + ct).type != 59)
            node = expr()
        else 
            node = new_node(0)
        skip(59)
    }

    return node;
}


function expr() -> struct Node*  (1472)
{
    struct Node *node = assign();
    struct Node *curr = node;
    while (*(tokens + ct).type == 44)
    {
        ct++
        curr->next_in_comma = assign()
        curr = curr->next_in_comma
    }

    return node;
}


function assign() -> struct Node*  (1485)
{
    struct Node *left = conditional();
    if (type_match(*(tokens + ct).type, 61, 282, 283, 285, 284, -(1)))
    {
        add_type(left)
        if (left->type != 2 && left->type != 16 && left->type != 24 || left->t->t == 3 || left->t->t == 2)
            error_token(&(*(tokens + ct)), "expression is not assignable")

        struct Node *node = new_node(6);
        ct++
        node->left = left
        node->right = assign()
        if (node->tok->type != 61)
        {
            struct Node *right = new_node(5);
            right->tok = new_temp_token(*(node->tok->str + 0))
            right->left = left
            right->right = node->right
            node->right = right
        }

        add_type(node)
        return node;
    }

    add_type(left)
    return left;
}


function conditional() -> struct Node*  (1516)
{
    struct Node *left = logical_or();
    if (*(tokens + ct).type == 63)
    {
        struct Node *node = new_node(23);
        ct++
        node->condition = left
        node->left = expr()
        skip(58)
        node->right = conditional()
        return node;
    }

    return left;
}


function logical_or() -> struct Node*  (1532)
{
    return binary(logical_and, 259, -(1));
}


function logical_and() -> struct Node*  (1537)
{
    return binary(equality, 258, -(1));
}


function equality() -> struct Node*  (1542)
{
    return binary(relational, 260, 261, -(1));
}


function relational() -> struct Node*  (1547)
{
    return binary(add, 60, 62, 262, 263, -(1));
}


function add() -> struct Node*  (1552)
{
    return binary(mul, 43, 45, -(1));
}


function mul() -> struct Node*  (1557)
{
    return binary(cast, 42, 47, 37, -(1));
}


function cast() -> struct Node*  (1562)
{
    if (*(tokens + ct).type == 40 && is_typename(&(*(tokens + ct + 1))))
    {
        struct Node *node = new_node(22);
        ct++
        node->cast_type = parse_type()
        skip(41)
        node->left = cast()
        return node;
    }

    return unary();
}


function unary() -> struct Node*  (1576)
{
    if (*(tokens + ct).type == 43)
    {
        ct++
        return cast();
    }
    else if (*(tokens + ct).type == 45)
    {
        struct Node *node = new_node(7);
        ct++
        node->left = cast()
        return node;
    }
    else if (*(tokens + ct).type == 38)
    {
        struct Node *node = new_node(17);
        ct++
        node->left = cast()
        return node;
    }
    else if (*(tokens + ct).type == 42)
    {
        struct Node *node = new_node(16);
        ct++
        node->left = cast()
        return node;
    }
    else if (*(tokens + ct).type == 33)
    {
        struct Node *node = new_node(14);
        ct++
        node->left = cast()
        return node;
    }
    else if (*(tokens + ct).type == 281)
    {
        struct Node *node = new_node(4);
        node->tok = new_temp_token(256)
        ct++
        struct Type *t = ((struct Type*)0);
        if (*(tokens + ct).type == 40 && is_typename(&(*(tokens + ct + 1))))
        {
            ct++
            t = parse_type()
            skip(41)
        }
        else 
        {
            struct Node *left = unary();
            t = add_type(left)
        }

        (NULL)
        if (t->t == 3)
            node->tok->int_val = ((long)t->size * t->array_size)
        else 
            node->tok->int_val = ((long)t->size)
        return node;
    }
    else if (*(tokens + ct).type == 275 || *(tokens + ct).type == 276)
    {
        struct Node *node = new_node(5);
        node->tok->type = ((*(tokens + ct).type == 275) ? (43) : (45)
        ct++
        node->left = unary()
        node->right = new_node(4)
        node->right->tok = new_temp_token(256)
        node->right->tok->int_val = ((long)1)
        struct Node *assign = new_node(6);
        assign->tok = new_temp_token(61)
        assign->left = node->left
        assign->right = node
        return assign;
    }

    return postfix();
}


function postfix() -> struct Node*  (1654)
{
    struct Node *left = primary();
    while (1)
    {
        if (*(tokens + ct).type == 91)
        {
            ct++
            struct Node *index = expr();
            skip(93)
            struct Node *node = new_node(5);
            node->tok = new_temp_token(43)
            node->left = left
            node->right = index
            struct Node *deref = new_node(16);
            deref->tok = new_temp_token(42)
            deref->left = node
            left = deref
        }
        else if (*(tokens + ct).type == 275 || *(tokens + ct).type == 276)
        {
            struct Node *node = new_node(14);
            node->left = left
            left = node
            ct++
        }
        else if (*(tokens + ct).type == 46 || *(tokens + ct).type == 288)
        {
            struct Node *tmp = new_node(24);
            tmp->right = left
            struct Type *type = add_type(left);
            if (*(tokens + ct).type == 288 && !(type->t == 1 && type->ptr_to->t == 7))
            {
                error_token(&(*(tokens + ct)), "expected struct pointer")
            }

            if (*(tokens + ct).type == 288)
                type = type->ptr_to

            if (type->t != 7)
                error_token(&(*(tokens + ct)), "expected struct type")

            ct++
            int i = 0;
            for (; i < type->field_count ;i++)
            {
                if (!(strcmp(*(type->field_name + i), *(tokens + ct).name)))
                    break ;

            }

            if (i == type->field_count)
                error_token(&(*(tokens + ct)), "undeclared struct member")

            struct Type *char_ptr = new_type(1);
            char_ptr->ptr_to = type_char
            struct Node *addr = left;
            if (*(tokens + ct - 1).type == 46)
            {
                addr = new_node(17)
                addr->left = left
            }

            implicit_cast(&(addr), char_ptr)
            struct Node *add = new_node(5);
            add->tok = new_temp_token(43)
            add->left = addr
            add->right = new_node(4)
            add->right->tok = new_temp_token(256)
            add->right->tok->int_val = ((long)*(type->field_offset + i))
            struct Type *t = new_type(1);
            struct Node *node;
            if (*(type->field_type + i)->t == 3)
            {
                t = *(type->field_type + i)
                implicit_cast(&(add), t)
                node = add
            }
            else 
            {
                t->ptr_to = *(type->field_type + i)
                implicit_cast(&(add), t)
                node = new_node(16)
                node->left = add
            }

            tmp->left = node
            skip(257)
            left = tmp
        }
        else 
            break ;
    }

    return left;
}


function primary() -> struct Node*  (1751)
{
    struct Node *node = ((struct Node*)0);
    if (*(tokens + ct).type == 256)
    {
        node = new_node(4)
        ct++
    }
    else if (*(tokens + ct).type == 274)
    {
        node = new_node(19)
        ct++
    }
    else if (*(tokens + ct).type == 40)
    {
        ct++
        node = expr()
        skip(41)
    }
    else if (*(tokens + ct).type == 257 && *(tokens + ct + 1).type == 40)
    {
        node = new_node(13)
        node->func = find_func(*(tokens + ct).name)
        if (!(node->func))
            error_token(node->tok, "undeclared function \"%s\"", *(tokens + ct).name)

        ct += ct + 2
        int count = 0;
        while (*(tokens + ct).type != 41)
        {
            if (!(strcmp(node->tok->name, "ASSERT")) && *(tokens + ct).type == 123)
                *(node->args + count) = statement()
            else 
                *(node->args + count) = assign()
            count++
            if (*(tokens + ct).type == 44)
                ct++
            else if (*(tokens + ct).type != 41)
                skip(41)

        }

        ct++
        node->arg_count = count
    }
    else if (*(tokens + ct).type == 257)
    {
        struct Var *var = find_var(*(tokens + ct).name);
        if (!(var))
        {
            for (int i = 0; i < enum_count ;i++)
            {
                if (!(strcmp(*(tokens + ct).name, *(enums + i).name)))
                {
                    node = new_node(4)
                    ct++
                    node->tok = new_temp_token(256)
                    node->tok->int_val = ((long)*(enums + i).value)
                    return node;
                }

            }

            error_token(&(*(tokens + ct)), "undeclared variable `%s`\n", *(tokens + ct).name)
        }

        node = new_node(2)
        node->var = var
        ct++
    }
    else 
        error_token(&(*(tokens + ct)), "expected an expression")
    return node;
}


function get_inst_suffix(int size) -> char*  (1822)
{
    if (size == 1)
        return "b";
    else if (size == 2)
        return "w";
    else if (size == 4)
        return "l";
    else if (size == 8)
        return "q";

    (NULL)
}


function get_size_name(int size) -> char*  (1835)
{
    if (size == 1)
        return "byte";
    else if (size == 2)
        return "short";
    else if (size == 4)
        return "long";
    else if (size == 8)
        return "quad";

    (NULL)
}


function log2_int(int x) -> int  (1848)
{
    int y = 0;
    while (x > 1)
    {
        x /= x / 2
        y++
    }

    return y;
}


function get_register_by_size(char* reg, int size) -> char*  (1859)
{
    char ***(rax + 0) = "al", *(rax + 1) = "ax", *(rax + 2) = "eax", *(rax + 3) = "rax";
    char ***(rdx + 0) = "dh", *(rdx + 1) = "dx", *(rdx + 2) = "edx", *(rdx + 3) = "rdx";
    char ***(rcx + 0) = "ch", *(rcx + 1) = "cx", *(rcx + 2) = "ecx", *(rcx + 3) = "rcx";
    char ***(rdi + 0) = "dil", *(rdi + 1) = "di", *(rdi + 2) = "edi", *(rdi + 3) = "rdi";
    char ***(rsi + 0) = "sil", *(rsi + 1) = "si", *(rsi + 2) = "esi", *(rsi + 3) = "rsi";
    char ***(r8 + 0) = "r8b", *(r8 + 1) = "r8w", *(r8 + 2) = "r8d", *(r8 + 3) = "r8";
    char ***(r9 + 0) = "r9b", *(r9 + 1) = "r9w", *(r9 + 2) = "r9d", *(r9 + 3) = "r9";
    char ***(r10 + 0) = "r10b", *(r10 + 1) = "r10w", *(r10 + 2) = "r10d", *(r10 + 3) = "r10";
    char ***(r11 + 0) = "r11b", *(r11 + 1) = "r11w", *(r11 + 2) = "r11d", *(r11 + 3) = "r11";
    size = log2_int(size)
    if (!(strcmp(reg, "rax")))
        return *(rax + size);

    if (!(strcmp(reg, "rdx")))
        return *(rdx + size);

    if (!(strcmp(reg, "rcx")))
        return *(rcx + size);

    if (!(strcmp(reg, "rdi")))
        return *(rdi + size);

    if (!(strcmp(reg, "rsi")))
        return *(rsi + size);

    if (!(strcmp(reg, "r8")))
        return *(r8 + size);

    if (!(strcmp(reg, "r9")))
        return *(r9 + size);

    if (!(strcmp(reg, "r10")))
        return *(r10 + size);

    if (!(strcmp(reg, "r11")))
        return *(r11 + size);

    (NULL)
}


function add_string_lit(char* s) -> int  (1894)
{
    for (int i = 0; i < strings_literal_count ;i++)
    {
        if (!(strcmp(s, *(strings_literal + i))))
            return i;

    }

    *(strings_literal + strings_literal_count) = s
    return strings_literal_count++;
}

int curr_label = 0;
int loop_counter = 0;
int curr_loop_label;
int curr_loop_is_for;
int stack_size = 0;

function push(char* reg) -> void  (1914)
{
    stack_size += stack_size + 8
    out("pushq %%%s // %d", reg, stack_size)
}


function pop(char* reg) -> void  (1920)
{
    stack_size -= stack_size - 8
    out("popq %%%s // %d", reg, stack_size)
    (NULL)
}


function gen(struct Node* node) -> void  (1927)
{
    if (!(node) || node->type == 0)
        return (NULL);

    if (node->type == 1)
    {
        struct Node *curr = node->next_stmt;
        while (curr)
        {
            gen(curr)
            curr = curr->next_stmt
        }

    }
    else if (node->type == 15)
    {
        if (!(node->body))
            return (NULL);

        if (!(strcmp(node->tok->name, "main")))
            fprintf(f, ".globl\t_main\n")

        stack_size = 0
        dbg("//%s %s(", get_type_str(node->func->ret_type), node->tok->name)
        for (int i = 0; i < node->param_count ;i++)
        {
            dbg("%s %s", get_type_str(*(node->params + i)->var->type), *(node->params + i)->var->name)
            if (i < node->param_count - 1)
                dbg(", ")

        }

        dbg(")\n")
        fprintf(f, "_%s:\n", node->tok->name)
        out("pushq %%rbp")
        out("movq %%rsp, %%rbp")
        stack_size = node->stack_size
        out("subq $%d, %%rsp // %d", node->stack_size, stack_size)
        char ***(reg + 0) = "rdi", *(reg + 1) = "rsi", *(reg + 2) = "rdx", *(reg + 3) = "rcx", *(reg + 4) = "r8", *(reg + 5) = "r9";
        for (int i = 0; i < node->param_count && i < 6 ;i++)
        {
            struct Var *v = *(node->params + i)->var;
            out("mov%s %%%s, -%d(%%rbp) //%s", get_inst_suffix(v->type->size), get_register_by_size(*(reg + i), v->type->size), v->offset, v->name)
        }

        if (node->param_count > 6)
        {
            int offset = *(node->params + 5)->var->offset + 8;
            int offset2 = 16;
            for (int i = 6; i < node->param_count ;i++)
            {
                out("movq %d(%%rbp), %%rax", offset2)
                out("mov%s %%%s, -%d(%%rbp) // %s", get_inst_suffix(*(node->params + i)->var->type->size), get_register_by_size("rax", *(node->params + i)->var->type->size), *(node->params + i)->var->offset, *(node->params + i)->var->name)
                offset += offset + 8
                offset2 += offset2 + 8
            }

        }

        gen(node->body)
        stack_size -= stack_size - node->stack_size
        out("addq $%d, %%rsp // %d", node->stack_size, stack_size)
        out("movq $0, %%rax")
        out("movq %%rbp, %%rsp")
        out("popq %%rbp")
        out("ret\n")
    }
    else if (node->type == 12)
    {
        struct Node *curr = node->first_stmt;
        dbg("//{ (%d)\n", node->tok->line)
        while (curr)
        {
            gen(curr)
            curr = curr->next_in_block
        }

        dbg("//}\n")
    }
    else if (node->type == 24)
    {
        gen(node->left)
    }
    else if (node->type == 18)
    {
        struct Node *curr = node->next_in_decl;
        while (curr)
        {
            if (curr->var->global)
            {
            }
            else if (!(curr->var->global) && curr->left)
                gen(curr->left)

            curr = curr->next_in_decl
        }

    }
    else if (node->type == 8)
    {
        gen(node->left)
        out("movq %%rbp, %%rsp")
        out("popq %%rbp")
        out("ret")
    }
    else if (node->type == 9)
    {
        int label = curr_label++;
        fprintf(f, "//if begin\n")
        gen(node->condition)
        out("cmpq $0, %%rax")
        out("je ELSE%d", label)
        gen(node->body)
        out("jmp END_IF%d", label)
        fprintf(f, "ELSE%d:\n", label)
        if (node->else_)
            gen(node->else_)

        fprintf(f, "END_IF%d:\n", label)
    }
    else if (node->type == 10)
    {
        int label = curr_label++;
        fprintf(f, "WHILE%d:\n", label)
        gen(node->condition)
        out("cmpq $0, %%rax")
        out("je WHILE_END%d", label)
        loop_counter++
        int s1 = curr_loop_label;
        int s2 = curr_loop_is_for;
        curr_loop_label = label
        curr_loop_is_for = 0
        gen(node->body)
        curr_loop_label = s1
        curr_loop_is_for = s2
        loop_counter++
        out("jmp WHILE%d", label)
        fprintf(f, "WHILE_END%d:\n", label)
    }
    else if (node->type == 11)
    {
        int label = curr_label++;
        fprintf(f, "//for init\n")
        gen(node->init)
        fprintf(f, "FOR%d:\n", label)
        if (node->condition)
        {
            gen(node->condition)
            out("cmpq $0, %%rax")
            out("je FOR_END%d", label)
        }

        loop_counter++
        int s1 = curr_loop_label;
        int s2 = curr_loop_is_for;
        curr_loop_label = label
        curr_loop_is_for = 1
        gen(node->body)
        loop_counter++
        curr_loop_label = s1
        curr_loop_is_for = s2
        fprintf(f, "FOR_INC%d:\n", label)
        gen(node->inc)
        out("jmp FOR%d", label)
        fprintf(f, "FOR_END%d:\n", label)
    }
    else if (node->type == 4)
    {
        if (node->t->t == 6)
            out("movabsq $%lld, %%rax", node->tok->int_val)
        else 
            out("movq $%lld, %%rax", node->tok->int_val)
    }
    else if (node->type == 19)
    {
        int id = add_string_lit(node->tok->name);
        out("leaq L_.str.%d(%%rip), %%rax", id)
    }
    else if (node->type == 2)
    {
        if (node->t->t == 3 || node->t->t == 7)
        {
            if (node->var->global)
            {
                out("movq _%s@GOTPCREL(%%rip), %%rax", node->var->name)
            }
            else 
            {
                out("movq %%rbp, %%rax // %s", node->var->name)
                out("subq $%d, %%rax", node->var->offset)
            }

        }
        else if (node->t->t == 8)
        {
            out("leaq _%s(%%rip), %%rax", node->tok->name)
        }
        else 
        {
            if (node->var->global)
            {
                if (node->t->is_unsigned)
                {
                    if (node->t->size < 4)
                        out("movz%sq _%s(%%rip), %%rax // %s", get_inst_suffix(node->t->size), node->var->name, node->var->name)
                    else 
                        out("mov%s _%s(%%rip), %%%s // %s", get_inst_suffix(node->t->size), node->var->name, get_register_by_size("rax", node->t->size), node->var->name)
                }
                else 
                {
                    if (node->t->size < 8)
                    {
                        out("movs%sq _%s(%%rip), %%rax", get_inst_suffix(node->t->size), node->var->name)
                    }
                    else 
                        out("movq _%s(%%rip), %%rax", node->var->name)
                }

            }
            else 
            {
                if (node->t->is_unsigned)
                {
                    if (node->t->size < 4)
                        out("movz%sq -%d(%%rbp), %%rax // %s", get_inst_suffix(node->t->size), node->var->offset, node->var->name)
                    else 
                        out("mov%s -%d(%%rbp), %%%s // %s", get_inst_suffix(node->t->size), node->var->offset, get_register_by_size("rax", node->t->size), node->var->name)
                }
                else 
                {
                    if (node->t->size < 8)
                    {
                        out("movs%sq -%d(%%rbp), %%rax // %s", get_inst_suffix(node->t->size), node->var->offset, node->var->name)
                    }
                    else 
                        out("movq -%d(%%rbp), %%rax // %s", node->var->offset, node->var->name)
                }

            }

        }

    }
    else if (node->type == 13)
    {
        if (!(strcmp(node->tok->name, "ASSERT")))
        {
            int label = curr_label++;
            char *s2 = node->tok->str;
            while (((int)*(s2)) != 10)
                s2++

            fprintf(f, "//%.*s", ((int)s2 - node->tok->str + 1), node->tok->str)
            gen(*(node->args + 0))
            out("movq %%rax, %%r12")
            gen(*(node->args + 1))
            out("cmpq %%r12, %%rax")
            out("je ASSERT_OK%d", label)
            out("movq $%d, %%rdi", node->tok->line)
            out("movq %%r12, %%rsi", node->tok->line)
            out("movq %%rax, %%rdx", node->tok->line)
            out("callq _error")
            fprintf(f, "ASSERT_OK%d:\n", label)
        }
        else 
        {
            char ***(reg + 0) = "rdi", *(reg + 1) = "rsi", *(reg + 2) = "rdx", *(reg + 3) = "rcx", *(reg + 4) = "r8", *(reg + 5) = "r9";
            dbg("//call %s\n", node->tok->name)
            for (int i = 0; i < node->arg_count && i < 6 ;i++)
            {
                gen(*(node->args + i))
                push("rax")
            }

            for (int i = 0; i < node->arg_count && i < 6 ;i++)
            {
                int last = node->arg_count;
                if (last > 6)
                    last = 6

                pop(*(reg + last - i - 1))
            }

            int s = stack_size;
            if (node->arg_count > 6)
                s += s + node->arg_count - 6 * 8

            int target = align(s, 16);
            (NULL)
            out("subq $%d, %%rsp // %d", target - s, stack_size + target - s)
            stack_size += stack_size + target - s
            for (int i = node->arg_count - 1; i >= 6 ;i++)
            {
                gen(*(node->args + i))
                push("rax")
            }

            out("xorq %%rax, %%rax")
            (NULL)
            out("callq _%s", node->tok->name)
            int add = target - s;
            if (node->arg_count > 6)
                add += add + node->arg_count - 6 * 8

            stack_size -= stack_size - add
            out("addq $%d, %%rsp // %d", add, stack_size)
        }

    }
    else if (node->type == 17)
    {
        if (node->left->type == 24)
            node->left = node->left->left

        if (node->left->type == 16)
        {
            gen(node->left->left)
        }
        else if (node->left->type == 2)
        {
            if (node->left->var->global)
            {
                out("movq _%s@GOTPCREL(%%rip), %%rax", node->left->var->name)
            }
            else 
            {
                out("movq %%rbp, %%rax // &%s", node->left->var->name)
                out("subq $%d, %%rax", node->left->var->offset)
            }

        }
        else if (node->left->type == 22)
        {
            node->left = node->left->left
            gen(node)
        }
        else 
            (NULL)
    }
    else if (node->type == 16)
    {
        gen(node->left)
        if (!(node->left->t->ptr_to))
            error_token(node->tok, "dereferencing a non-pointer lvalue")

        if (node->t->t == 7)
            (NULL)
        else if (node->t->size < 8)
            out("movs%sq (%%rax), %%rax", get_inst_suffix(node->t->size))
        else 
            out("movq (%%rax), %%rax")
    }
    else if (node->type == 7)
    {
        gen(node->left)
        if (node->left->t->ptr_to)
            error_token(node->tok, "negating a pointer")

        out("xorq %%r10, %%r10")
        out("subq %%rax, %%r10")
        out("movq %%r10, %%rax")
    }
    else if (node->type == 22)
    {
        dbg("//cast to (%s)\n", get_type_str(node->t))
        gen(node->left)
        struct Type *t1 = node->left->t;
        struct Type *t2 = node->t;
        if (node->t->t == 3)
        {
            t2 = new_type(1)
            t2->ptr_to = node->t->ptr_to
        }

        if (!(t1->is_unsigned) && !(t2->is_unsigned))
        {
            if (t2->size < t1->size)
            {
                out("movs%sq %%%s, %%r10", get_inst_suffix(t2->size), get_register_by_size("rax", t2->size))
                out("movq %%r10, %%rax")
            }
            else 
                (NULL)
        }
        else if (t2->is_unsigned)
        {
            out("xorq %%r10, %%r10")
            out("mov%s %%%s, %%%s", get_inst_suffix(t2->size), get_register_by_size("rax", t2->size), get_register_by_size("r10", t2->size))
            out("movq %%r10, %%rax")
        }
        else 
        {
            if (t2->size < 8)
            {
                out("xorq %%r10, %%r10")
                out("mov%s %%%s, %%%s", get_inst_suffix(t2->size), get_register_by_size("rax", t2->size), get_register_by_size("r10", t2->size))
                out("movs%sq %%%s, %%rax", get_inst_suffix(t2->size), get_register_by_size("r10", t2->size))
            }

        }

    }
    else if (node->type == 5)
    {
        gen(node->left)
        if (type_match(node->tok->type, 258, 259, -(1)))
        {
            int label = curr_label++;
            int is_and = node->tok->type == 258;
            out("cmpq $0, %%rax")
            out("movq $%d, %%rax", !(is_and))
            out("j%se AND_OR%d", ((is_and) ? ("") : ("n"), label)
            gen(node->right)
            out("cmpq $0, %%rax")
            out("setne %%al")
            out("movzbq %%al, %%rax")
            fprintf(f, "AND_OR%d:\n", label)
        }
        else 
        {
            push("rax")
            gen(node->right)
            out("movq %%rax, %%r10")
            pop("rax")
            (NULL)
            (NULL)
            if (node->tok->type == 43 || node->tok->type == 45)
            {
                if (node->left->t->ptr_to && !(node->right->t->ptr_to))
                    out("imulq $%d, %%r10", node->left->t->ptr_to->size)
                else if (node->right->t->ptr_to && !(node->left->t->ptr_to) && node->tok->type == 43)
                    out("imulq $%d, %%rax", node->right->t->ptr_to->size)

            }

            if (node->tok->type == 43)
                out("addq %%r10, %%rax")
            else if (node->tok->type == 45)
                out("subq %%r10, %%rax")
            else if (node->tok->type == 42)
                out("imulq %%r10, %%rax")
            else if (node->tok->type == 47 || node->tok->type == 37)
            {
                if (!(node->t->is_unsigned))
                {
                    out("cqto")
                    out("idivq %%r10")
                }
                else 
                {
                    out("xorq %%rdx, %%rdx")
                    out("divq %%r10")
                }

                if (node->tok->type == 37)
                    out("movq %%rdx, %%rax")

            }
            else if (type_match(node->tok->type, 260, 261, 262, 263, 60, 62, -(1)))
            {
                char *s = "";
                if (node->tok->type == 260)
                    s = "e"
                else if (node->tok->type == 261)
                    s = "ne"
                else if (node->tok->type == 60)
                    s = "l"
                else if (node->tok->type == 62)
                    s = "g"
                else if (node->tok->type == 262)
                    s = "le"
                else if (node->tok->type == 263)
                    s = "ge"
                else 
                    (NULL)
                out("cmpq %%r10, %%rax")
                out("set%s %%al", s)
                out("andb $1, %%al")
                out("movzbq %%al, %%rax")
            }

            if (node->left->t->ptr_to && node->right->t->ptr_to && node->tok->type == 45)
            {
                out("movq $%d, %%r10", node->left->t->ptr_to->size)
                out("xorq %%rdx, %%rdx")
                out("divq %%r10")
            }

        }

    }
    else if (node->type == 6)
    {
        if (node->left->type == 24)
            node->left = node->left->left

        if (node->left->type == 16)
        {
            gen(node->right)
            if (node->t->t == 7)
            {
                (NULL)
                push("rax")
                gen(node->left)
                pop("rsi")
                out("movq %%rax, %%rdi")
                out("movq $%d, %%rdx", node->t->size)
                out("callq _memcpy")
            }
            else 
            {
                push("rax")
                gen(node->left->left)
                if (!(node->left->left->t->ptr_to))
                    error_token(node->tok, "dereferencing a non-pointer lvalue")

                pop("r10")
                out("mov%s %%%s, (%%rax)", get_inst_suffix(node->t->size), get_register_by_size("r10", node->t->size))
            }

        }
        else if (node->left->type == 2)
        {
            gen(node->right)
            node->left->t = node->left->var->type
            (NULL)
            if (node->t->t == 3)
                error_token(node->tok, "array is constant")

            if (node->left->var->global)
            {
                if (node->t->t == 7)
                    (NULL)

                out("mov%s %%%s, _%s(%%rip)", get_inst_suffix(node->t->size), get_register_by_size("rax", node->t->size), node->left->var->name)
            }
            else 
            {
                if (node->t->t == 7)
                {
                    (NULL)
                    out("movq %%rbp, %%rdi")
                    out("subq $%d, %%rdi", node->left->var->offset)
                    out("movq %%rax, %%rsi")
                    out("movq $%d, %%rdx", node->left->var->type->size)
                    out("callq _memcpy")
                }
                else 
                {
                    out("mov%s %%%s, -%d(%%rbp) // %s = rax", get_inst_suffix(node->t->size), get_register_by_size("rax", node->t->size), node->left->var->offset, node->left->var->name)
                }

            }

        }
        else 
            (NULL)
    }
    else if (node->type == 20)
    {
        if (!(loop_counter))
            error_token(node->tok, "'continue' statement not in loop statement")

        if (curr_loop_is_for)
            out("jmp FOR_INC%d", curr_loop_label)
        else 
            out("jmp WHILE%d", curr_loop_label)
    }
    else if (node->type == 21)
    {
        if (!(loop_counter))
            error_token(node->tok, "'break' statement not in loop statement")

        if (curr_loop_is_for)
            out("jmp FOR_END%d", curr_loop_label)
        else 
            out("jmp WHILE_END%d", curr_loop_label)
    }
    else if (node->type == 14)
    {
        gen(node->left)
        if (node->tok->type == 33)
        {
            out("cmpq $0, %%rax")
            out("setne %%al")
            out("xorb $-1, %%al")
            out("andb $1, %%al")
            out("movzbq %%al, %%rax")
        }
        else if (node->tok->type == 275 || node->tok->type == 276)
        {
            push("rax")
            struct Node *one = new_node(4);
            one->tok = new_temp_token(256)
            one->tok->int_val = ((long)((node->tok->type == 275) ? (1) : (-(1)))
            struct Node *assign = new_node(6);
            assign->tok = new_temp_token(61)
            assign->left = node->left
            assign->right = new_node(5)
            assign->right->tok = new_temp_token(43)
            assign->right->left = node->left
            assign->right->right = one
            add_type(assign)
            gen(assign)
            pop("rax")
        }
        else 
            (NULL)
    }
    else if (node->type == 23)
    {
        int label = curr_label++;
        gen(node->condition)
        out("cmpq $0, %%rax")
        out("je QUES%d", label)
        gen(node->left)
        out("jmp QUES_END%d", label)
        fprintf(f, "QUES%d:\n", label)
        gen(node->right)
        fprintf(f, "QUES_END%d:\n", label)
    }
    else 
        (NULL)
    if (node->next_in_comma)
        gen(node->next_in_comma)

}

int tab;

function print(struct Node* node) -> void  (2602)
{
    if (!(node))
        return (NULL);

    if (!(node) || node->type == 0)
        printf("(NULL)")
    else if (node->type == 1)
    {
        struct Node *curr = node->next_stmt;
        while (curr)
        {
            print(curr)
            curr = curr->next_stmt
        }

    }
    else if (node->type == 15)
    {
        printf("\nfunction %s(", node->tok->name)
        for (int i = 0; i < node->param_count ;i++)
        {
            printf("%s %s", get_type_str(*(node->params + i)->var->type), *(node->params + i)->var->name)
            if (i < node->param_count - 1)
                printf(", ")

        }

        printf(") -> %s  (%d)\n", get_type_str(node->func->ret_type), node->tok->line)
        print(node->body)
        printf("\n")
    }
    else if (node->type == 12)
    {
        printf("%*s{\n", tab, "")
        tab += tab + 4
        struct Node *curr = node->first_stmt;
        while (curr)
        {
            printf("%*s", tab, "")
            print(curr)
            printf("\n")
            curr = curr->next_in_block
        }

        tab -= tab - 4
        printf("%*s}\n", tab, "")
    }
    else if (node->type == 18)
    {
        struct Node *curr = node->next_in_decl;
        printf("%s ", get_type_str(node->decl_type))
        while (curr)
        {
            struct Type *t = curr->var->type;
            while (t != node->decl_type)
            {
                t = t->ptr_to
                printf("*")
            }

            if (!(curr->left))
                printf("%s", curr->var->name)
            else 
                print(curr->left)
            if (curr->next_in_decl)
                printf(", ")
            else 
                printf(";")
            if (curr->var->global)
                printf("\n")

            curr = curr->next_in_decl
        }

    }
    else if (node->type == 8)
    {
        printf("return ")
        if (node->left)
            print(node->left)

        printf(";")
    }
    else if (node->type == 9 || node->type == 10)
    {
        printf("%s (", token_type_name(node->tok->type))
        print(node->condition)
        printf(")\n")
        if (node->body->type != 12)
            printf("%*s", tab + 4, "")

        print(node->body)
        if (node->body->type != 12)
            printf("\n")

        if (node->else_)
        {
            printf("%*selse ", tab, "")
            if (node->else_->type != 9)
            {
                printf("\n")
                if (node->else_->type != 12)
                    printf("%*s", tab + 4, "")

            }

            print(node->else_)
        }

    }
    else if (node->type == 11)
    {
        printf("for (")
        print(node->init)
        if (!(node->init) || node->init->type != 18)
            printf(";")

        printf(" ")
        print(node->condition)
        printf(" ;")
        print(node->inc)
        printf(")\n")
        if (node->body->type != 12)
            printf("%*s", tab + 4, "")

        print(node->body)
    }
    else if (node->type == 24)
    {
        print(node->right)
        printf("%s", token_type_name(node->tok->type))
        printf("%s", node->tok + 1->name)
    }
    else if (node->type == 4)
        printf("%lld", node->tok->int_val)
    else if (node->type == 2)
        printf("%s", node->var->name)
    else if (node->type == 19)
        printf("\"%s\"", node->tok->name)
    else if (node->type == 13)
    {
        printf("%s(", node->tok->name)
        for (int i = 0; i < node->arg_count ;i++)
        {
            print(*(node->args + i))
            if (i < node->arg_count - 1)
                printf(", ")

        }

        printf(")")
    }
    else if (node->type == 17 || node->type == 16 || node->type == 7)
    {
        printf("%c(", node->tok->type)
        print(node->left)
        printf(")")
    }
    else if (node->type == 22)
    {
        printf("((%s)", get_type_str(node->t))
        print(node->left)
        printf(")")
    }
    else if (node->type == 5)
    {
        print(node->left)
        printf(" %s ", token_type_name(node->tok->type))
        print(node->right)
    }
    else if (node->type == 6)
    {
        print(node->left)
        printf(" %s ", token_type_name(node->tok->type))
        print(node->right)
    }
    else if (node->type == 20)
        printf("continue ;")
    else if (node->type == 21)
        printf("break ;")
    else if (node->type == 14)
    {
        if (node->tok->type == 33)
        {
            printf("!(")
            print(node->left)
            printf(")")
        }
        else 
        {
            print(node->left)
            printf("++")
        }

    }
    else if (node->type == 23)
    {
        printf("((")
        print(node->condition)
        printf(") ? (")
        print(node->left)
        printf(") : (")
        print(node->right)
        printf(")")
    }

    if (node->next_in_comma)
    {
        printf(", ")
        print(node->next_in_comma)
    }

}


function read_entire_file(char* name) -> char*  (2799)
{
    char *buffer = ((char*)0);
    long length;
    struct FILE *file = fopen(name, "r");
    if (file)
    {
        fseek(file, 0, 2)
        length = ftell(file)
        fseek(file, 0, 0)
        buffer = ((char*)malloc(length + ((long)1)))
        if (buffer)
            fread(buffer, 1, length, file)

        *(buffer + length) = ((char)0)
        fclose(file)
    }

    return buffer;
}


function main() -> int  (2818)
{
    filename = "final.c"
    type_long = new_type(6)
    type_int = new_type(0)
    type_short = new_type(4)
    type_char = new_type(5)
    type_void = new_type(2)
    program_str = read_entire_file(filename)
    struct Node *node = parse(program_str);
    char *out_name = strdup(filename);
    *(out_name + strlen(out_name) - 1) = ((char)115)
    f = fopen(out_name, "w")
    (NULL)
    print(node)
    gen(node)
    out(".section	__DATA,__data")
    for (int i = 0; i < curr_scope->var_count ;i++)
    {
        struct Node *decl = *(curr_scope->vars + i)->decl;
        if (decl->left && decl->left->right->type != 4)
        {
            printf("error name: %s %c\n", decl->var->name, decl->left->tok->type)
            error_token(decl->left->tok, "todo: evaluate constant expressions\n")
        }

        if (decl->var->type->t == 3)
        {
            out(".comm _%s,%d,%d\n", decl->var->name, decl->var->type->array_size * decl->var->type->size, 4)
        }
        else 
        {
            out(".globl _%s", decl->var->name)
            int align = log2_int(decl->var->type->size);
            if (align)
                out(".p2align %d", align)

            fprintf(f, "_%s:\n", *(curr_scope->vars + i)->name)
            out(".%s %d\n", get_size_name(*(curr_scope->vars + i)->type->size), ((!(decl->left)) ? (((long)0)) : (decl->left->right->tok->int_val))
        }

    }

    for (int i = 0; i < strings_literal_count ;i++)
    {
        fprintf(f, "L_.str.%d:\n", i)
        out(".asciz \"%s\"", *(strings_literal + i))
    }

}

